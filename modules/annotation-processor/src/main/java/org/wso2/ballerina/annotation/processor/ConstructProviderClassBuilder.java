/*
 * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.wso2.ballerina.annotation.processor;

import org.wso2.ballerina.core.exception.BallerinaException;
import org.wso2.ballerina.core.interpreter.SymScope;
import org.wso2.ballerina.core.model.Symbol;
import org.wso2.ballerina.core.model.SymbolName;
import org.wso2.ballerina.core.nativeimpl.NativeConstructLoader;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

import javax.annotation.processing.Filer;
import javax.tools.FileObject;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;

/**
 * Builder class to generate the ballerina constructs provider class.
 * The class generated by this builder will register all the annotated 
 * classes as {@link Symbol}s to the global symbol table, via java SPI.
 */
public class ConstructProviderClassBuilder {
    
    private static final String SERVICES_PREFIX = File.separator + "services" + File.separator;
    private static final String META_INF = "META-INF";
    private Writer sourceFileWriter;
    private String className;
    private String packageName;
    private final String importPkg = "import " + SymScope.class.getCanonicalName() + ";\n" + 
                             "import " + Symbol.class.getCanonicalName() + ";\n" + 
                             "import " + SymbolName.class.getCanonicalName() + ";\n" + 
                             "import " + NativeConstructLoader.class.getCanonicalName() + ";\n";
    
    /**
     * Create a construct provider builder.
     * 
     * @param filer         {@link Filer} of the current processing environment
     * @param packageName   Package name of the generated construct provider class
     * @param className     Class name of the generated construct provider class
     */
    public ConstructProviderClassBuilder(Filer filer, String packageName, String className) {
        this.packageName = packageName;
        this.className = className;
        
        // Initialize the class writer. 
        initClassWriter(filer);
        
        // Create config file int META-INF/services directory
        createServiceMetaFile(filer);
    }
    
    /**
     * Initialize the class writer. Write static codes of the including:
     * <ul>
     * <li>The package name</li>
     * <li>Package imports</li>
     * <li>Class definition</li>
     * <li>Public constructor with no parameters</li>
     * <li>Method name for load() method</li>
     * </ul>
     * @param filer
     */
    private void initClassWriter(Filer filer) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("package " + packageName + ";\n");
        stringBuilder.append(importPkg);
        stringBuilder.append("public class " + className + 
                " implements " + NativeConstructLoader.class.getSimpleName() + " {\n");
        stringBuilder.append("public " + className + "() {}\n");
        stringBuilder.append("public void load(" + SymScope.class.getSimpleName() + " globalScope) {\n");
        
        try {
            JavaFileObject javaFile = filer.createSourceFile(packageName + "." + className);
            sourceFileWriter = javaFile.openWriter();
            sourceFileWriter.write(stringBuilder.toString());
        } catch (IOException e) {
            throw new BallerinaException("failed to initialize source generator: " + e.getMessage());
        }
    }
    
    /**
     * Add a native construct to this class builder.
     * 
     * @param constructName     Native construct Name
     * @param className         Name of the implementation class
     */
    public void addNativeConstruct(String constructName, String className) {
        try {
            sourceFileWriter.write("globalScope.insert(new " + SymbolName.class.getSimpleName() + "(\"" + 
                    constructName + "\"), new " + Symbol.class.getSimpleName() + "());\n");
        } catch (IOException e) {
            throw new BallerinaException("failed to write to source file: " + e.getMessage());
        }
    }
    
    /**
     * Build the class. Append the remaining implemented methods and and write the source
     * file to the target (package) location.
     */
    public void build() {
        try {
            sourceFileWriter.write("}\n}\n");
        } catch (IOException e) {
            throw new BallerinaException("error while writing source to file: " + e.getMessage());
        } finally {
            if (sourceFileWriter != null) {
                try {
                    sourceFileWriter.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
    
    /**
     * Create the configuration file in META-INF/services, required for java service 
     * provider api.
     * 
     * @param filer     {@link Filer} associated with this annotation processor.
     */
    private void createServiceMetaFile(Filer filer) {
        Writer condfigWriter = null;
        
        /* 
         * Here were cannot use JavaFileObject to write the config file, as META-INF is
         * treated as an unsupported path by the JavaFileObject implementation.
         * Hence using native java.io operations to generate the resource file.
         */
        try {
            //Find the location of the resource/META-INF directory.
            FileObject metaFile = filer.getResource(StandardLocation.CLASS_OUTPUT, "", META_INF);

            // Create a new file, having the NativeConstructLoader class's fully qualified path, as the name.
            File config = new File(metaFile.toUri().getPath() + SERVICES_PREFIX + 
                    NativeConstructLoader.class.getCanonicalName());
            if (!config.getParentFile().exists() || !config.getParentFile().isDirectory()) {
                boolean created = config.getParentFile().mkdirs();
                if (!created) {
                    throw new BallerinaException("error creating the package structure for " + 
                            config.getParentFile().getPath());
                }
            }
            boolean fileCreated = config.createNewFile();
            if (!fileCreated) {
                throw new BallerinaException("failed to create the file: " + config.getPath());
            }
            
            // write the fully qualified name of the generate class, to the created file
            condfigWriter = new OutputStreamWriter(new FileOutputStream(config), StandardCharsets.UTF_8);
            condfigWriter.write(packageName + "." + className);
        } catch (IOException e) {
            throw new BallerinaException("error while generating config file: " + e.getMessage());
        } finally {
            if (condfigWriter != null) {
                try {
                    condfigWriter.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
}
